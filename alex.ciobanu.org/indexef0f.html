<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>asm &#8211; YAPB</title>
	<atom:link href="https://alex.ciobanu.org/?feed=rss2&#038;tag=asm" rel="self" type="application/rss+xml" />
	<link>https://alex.ciobanu.org</link>
	<description>Yet Another Programming Blog</description>
	<lastBuildDate>Mon, 15 Jun 2009 06:46:17 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.2.2</generator>

<image>
	<url>https://alex.ciobanu.org/files/uploads/2018/05/7327309-150x150.jpg</url>
	<title>asm &#8211; YAPB</title>
	<link>https://alex.ciobanu.org</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Extending TObject with data at runtime</title>
		<link>https://alex.ciobanu.org/?p=232</link>
				<comments>https://alex.ciobanu.org/?p=232#comments</comments>
				<pubDate>Sat, 13 Jun 2009 15:25:24 +0000</pubDate>
		<dc:creator><![CDATA[Alexandru Ciobanu]]></dc:creator>
				<category><![CDATA[Software Development]]></category>
		<category><![CDATA[asm]]></category>
		<category><![CDATA[delphi]]></category>
		<category><![CDATA[embarcadero]]></category>
		<category><![CDATA[LinkedIn]]></category>
		<category><![CDATA[rtl]]></category>

		<guid isPermaLink="false">http://alex.ciobanu.org/?p=232</guid>
				<description><![CDATA[In a recent comment on this blog Patrick van Logchem suggested a way of extending an existing object instance with custom data at run-time (originally the idea of Thorsten Engler). The main idea is to be able to... ]]></description>
								<content:encoded><![CDATA[<p>In a recent comment on this blog Patrick van Logchem suggested a way of extending an existing object instance with custom data at run-time (originally the idea of Thorsten Engler). The main idea is to be able to &#8220;assign&#8221; to an arbitrary object (whose sources you cannot change) some other object at run-time. This may prove to be useful in different scenarios when you need some additional data to be carried by an object.</p>
<p>The suggested idea was to use the monitor field which all <em>TObject</em> instances have. If you are not familiar with monitors in Delphi, let me explain: All <em>TObject</em> instances carry a new &#8220;hidden&#8221; field which is a pointer to a <em>TMonitor</em> (see System unit) structure. This referenced <em>TMonitor</em> structure is actually a <a href="http://en.wikipedia.org/wiki/Monitor_(synchronization)">kind of synchronization object</a> that lets you solve some common threading tasks easier. You can read more about this in other posts, since this post is about using that field to store data.</p>
<p>The restrictions:</p>
<ul>
<li>The solution must not be too simplistic. Simply rewriting the pointer in <em>TObject</em> instances is not allowed.</li>
<li>Normal monitor routines must function as they did before. This means that we must store a real monitor there alongside with the data.</li>
<li>No custom functions to simulate monitor support, and no class helpers. See previous item.</li>
<li>The attached data must be disposed when the object is disposed so to avoid memory and resource leaks.</li>
</ul>
<p>The features:</p>
<ul>
<li>Possibility to extend an object with another object: <span style="text-decoration: underline;">ExtendObject(Object, Extension);</span></li>
<li>Possibility to query an object for an extension: <span style="text-decoration: underline;">GetObjectExtension(Object): Extension;</span></li>
<li>Possibility to remove an extension from an object: <span style="text-decoration: underline;">RemoveObjectExtension(Object): Extension;</span></li>
<li>Object is any type of object in Delphi! No restrictions, no common ancestor; just plain <em>TObject</em>!</li>
<li>Extension is also simply a <em>TObject</em> value. It&#8217;s user-defined in it&#8217;s implementation and purpose.</li>
</ul>
<p>The first implementation I came up with is non-intrusive. I wanted to avoid patching the System exposed functions at run-time. The following list enumerates the design and restrictions of the first implementation:</p>
<ul>
<li>The unit must me USED directly after the inclusion of <strong>SysUtils</strong> in the main source file. This is an inconvenience of course, but it is a required one. Note that the unit must be included AFTER and not BEFORE SysUtils.</li>
<li>The unit overrides the values in the <strong>System.MonitorSupport</strong> variable and inserts it&#8217;s own custom routines used to obtain and release synchronization objects.</li>
<li>The unit uses the old <em>System.MonitorSupport</em> routines to do the real job. These routines are normally provided by the SysUtils unit &#8212; thus the dependency on SysUtils.</li>
<li>For each synchronization object requested, my custom routines return a fake handle which is actually a pointer to a structure containing a real handle and a <em>TObject</em> value.</li>
<li>This method does not use the monitor field per se; rather, it uses a field in the monitor itself.</li>
<li>Class helpers are used in implementation section to obtain access to internal method in the <em>TMonitor</em> structure.</li>
<li>While this method is non-intrusive at assembly level, it is surely more complex and uses more CPU cycles.</li>
</ul>
<p>The second implementation is intrusive! It patches some functions in System unit so that my handler are executed in certain scenarios. The following list enumerates what&#8217;s going on in this one:</p>
<ul>
<li>The unit should be USED after or before SysUtils. This restriction comes from the fact that monitors initialized before this unit is included have a different format. So there may be (or maybe not) problems.</li>
<li>Two functions are patched in System unit: <em>TMonitor.Destroy(TObject) and TMonitor.Create()</em>. First one is executed when a monitor is destroyed &#8211; normally at object death; and the second one is called when a monitor value is needed for the first time.</li>
<li>The two injected functions do basically the same thing as the System versions, with a slight turn &#8211; a<span style="text-decoration: underline;"> TMonitor + Pointer</span> value is created/destroyed. This bonus Pointer value hold the extension object.</li>
<li>Class helpers are used internally to gain access to some monitor support routines.</li>
<li>This method does not incur any overhead on normal monitor operations, so it is the preferred one.</li>
</ul>
<p>And now to some code:</p>
<pre class="brush: delphi; title: ; notranslate">
uses
  SysUtils,
  ObjectExtensions_Intrusive;

type
  TStrExtenstion = class
  end;

  TIntExtension = class
  end;

procedure DoStuff(const A: TObject);
var
  Extension: TObject;
begin
  if A = nil then
    Exit;

  Extension := GetObjectExtension(A);

  if Extension = nil then
    Exit;

  WriteLn(Extension.ClassName);
end;

var
  a, b, c: TObject;
begin
  a := TObject.Create;
  b := TObject.Create;
  c := TObject.Create;

  ExtendObject(a, TStrExtenstion.Create);
  ExtendObject(b, TIntExtension.Create);

  DoStuff(a);
  DoStuff(b);
  DoStuff(c);

  ReadLn;
end.
</pre>
<p>It&#8217;s not hard to imagine that this method can be used is different circumstances &#8211; the ideas are all yours!</p>
<p><strong><span style="color: #ff0000;">MEGA WARNING: The attached code is barely tested, possibly unstable and even worse &#8211; maybe destructive. This is just a fun and proof of concept code and not something that can be used in applications.</span></strong></p>
<p><strong>The code can be found in this archive: </strong>[download#41]<br />
<strong>Mentioned the authors of the idea.</strong></p>
]]></content:encoded>
							<wfw:commentRss>https://alex.ciobanu.org/?feed=rss2&#038;p=232</wfw:commentRss>
		<slash:comments>9</slash:comments>
							</item>
		<item>
		<title>FastMove: Optimizing System.Move</title>
		<link>https://alex.ciobanu.org/?p=39</link>
				<comments>https://alex.ciobanu.org/?p=39#comments</comments>
				<pubDate>Thu, 04 Dec 2008 13:36:53 +0000</pubDate>
		<dc:creator><![CDATA[Alexandru Ciobanu]]></dc:creator>
				<category><![CDATA[Software Development]]></category>
		<category><![CDATA[asm]]></category>
		<category><![CDATA[delphi]]></category>
		<category><![CDATA[lgpl]]></category>
		<category><![CDATA[LinkedIn]]></category>
		<category><![CDATA[rtl]]></category>

		<guid isPermaLink="false">http://alex.ciobanu.org/?p=39</guid>
				<description><![CDATA[This post describes a technique that can be used to optimize some RTL functions at run-time. At the end of the post there&#8217;s a unit; add it to your uses list (preferably as the first one) and the... ]]></description>
								<content:encoded><![CDATA[<p>This post describes a technique that can be used to optimize some RTL functions at run-time. At the end of the post there&#8217;s a unit; add it to your uses list (preferably as the first one) and the <em>System.Move</em> routine will gain a significant speed boost. The unit will patch up the <em>Move </em>routine at run-time with <strong>MMX/SSE/SSE2/SSE3</strong> versions depending on what <em>SIMD</em> sets your CPU supports.</p>
<p>It performs these steps at run-time (in initialization section):</p>
<ol>
<li>Detect the supported SIMD sets using CPUID instruction. (see <em>GetSupportedSimdInstructionSets</em>, <em>CPUIIDSupports</em>, <em>CPUID</em> functions)</li>
<li>Detect the L2 cache size of your CPU to be used in optimizing the moving operation. (see <em>GetL2CacheSize</em> and <em>GetExtendedL2CacheSize</em> functions)</li>
<li>Depending on what <em>SIMD </em>sets are supported the best function variant is used (<strong>SSE3</strong>, then <strong>SSE2</strong>, <strong>SSE</strong> and <strong>MMX</strong> as the last option).</li>
<li>If your CPU doesn&#8217;t have support for any of those <em>SIMD</em> sets the original Move is left untouched.</li>
<li>After the proper variant of the function has been selected, the System.Move routine is patched and a &#8220;JMP NEW_OPTIMIZED_VERSION&#8221; jump is written over the first instructions &#8212; this forces the use of our optimized versions. (see <em>PatchMethod </em>function)</li>
<li>VirtualProtect windows function to un-protect the address space in which System.Move routine resides and then restore the protection.</li>
</ol>
<p>Of course I could have just exported those function variants and make them available to consumer code, but he interesting side-effect of run-time patching is that all code in Delphi that uses Move will get that speed boost, including RTL and VCL units. Anyway, no more words, get your copy now (while it&#8217;s hot):<br />
<code>[download#17] </code><br />
<strong>(Available under LGPL License &#8211; the original incense of the YAWE project)</strong></p>
<p><em><span style="color: #ff0000;"><br />
Note: All SIMD versions of Move method were written by Seth and initially included in our <a href="http://code.google.com/p/yawe-mmorpg/">YAWE</a> project. You can find much more interesting stuff if you look at the code we&#8217;ve laid down there.</span></em></p>
]]></content:encoded>
							<wfw:commentRss>https://alex.ciobanu.org/?feed=rss2&#038;p=39</wfw:commentRss>
		<slash:comments>2</slash:comments>
							</item>
		<item>
		<title>Abstract methods (or &#8220;why not&#8221;)</title>
		<link>https://alex.ciobanu.org/?p=38</link>
				<comments>https://alex.ciobanu.org/?p=38#respond</comments>
				<pubDate>Wed, 03 Dec 2008 16:30:07 +0000</pubDate>
		<dc:creator><![CDATA[Alexandru Ciobanu]]></dc:creator>
				<category><![CDATA[Software Development]]></category>
		<category><![CDATA[asm]]></category>
		<category><![CDATA[delphi]]></category>
		<category><![CDATA[LinkedIn]]></category>
		<category><![CDATA[oop]]></category>
		<category><![CDATA[rtl]]></category>

		<guid isPermaLink="false">http://alex.ciobanu.org/?p=38</guid>
				<description><![CDATA[I always considered the implementation of abstract methods in Delphi to be a hack, mostly because there is no way (or is there?) to treat this: &#8220;[DCC Warning] W1020 Constructing instance of a class containing abstract method.&#8221; warning... ]]></description>
								<content:encoded><![CDATA[<p>I always considered the implementation of abstract methods in Delphi to be a hack, mostly because there is no way (or is there?) to treat this: <span style="color: #ff0000;">&#8220;[DCC Warning] W1020 Constructing instance of a class containing abstract method.&#8221;</span> warning as a compile error. We all know  that a slot is reserved in the abstract class for each virtual (and abstract) method it holds. Delphi by default initializes those slots with addresses to _<em>AbstractError</em> routine in <em>System</em> unit.</p>
<p>This is how it&#8217;s defined in Delphi 2009:</p>
<pre class="brush: delphi; title: ; notranslate">
procedure _AbstractError;
begin
  if Assigned(AbstractErrorProc) then
    AbstractErrorProc;
  _RunError(210);  // loses return address
end;
</pre>
<p>AbstractErrorProc is being set up by <em>SysUtils</em> (in initialization section) if you include it in your application to be handled like this:</p>
<pre class="brush: delphi; title: ; notranslate">
procedure AbstractErrorHandler;
begin
  raise EAbstractError.CreateRes(@SAbstractError);
end;
</pre>
<p>Unfortunately we cannot plug-in our custom handler and hope to just bypass all abstract errors because a <em>_RunError(210);</em> call will be performed in any case by _<em>AbstractError</em> function &#8212; which would kill the application anyway.</p>
<p>But if you still want to hack your way through this default behavior, there are 2 ways to do it. Note that those will only work for abstract functions with no parameters &#8212; otherwise the stack will become corrupted.</p>
<p>Direct memory manipulation method:</p>
<pre class="brush: delphi; title: ; notranslate">
type
  TAbstractClass = class
    procedure AbstractMethod; virtual; abstract;
  end;

var
  PtrToAbErr : ^Pointer;
  C3 : ^Byte;

begin
  { Get the pointer to the function in slot 0 of VPTR }
  PtrToAbErr := Pointer(TAbstractClass);

  { Point to the first byte of _AbstractError routine }
  C3 := PtrToAbErr^;

  { Overwrite the first byte with a RET instruction}
  C3^ := $C3;

  WriteLn('We''ve got here! Hooray!');
  ReadLn;
end.
</pre>
<p>This method will not work if the memory in which <em>_AbstractError</em> resides is write-protected. You would have to manipulate the permissions first.</p>
<p>The second method will work but depends on the RTL&#8217;s implementation of <em>_AbstractError</em>:</p>
<pre class="brush: delphi; title: ; notranslate">
type
  TAbstractClass = class
    procedure AbstractMethod; virtual; abstract;
  end;

procedure MyHndlr();
asm
  ADD ESP, 4
  RET
end;

var
  O : TAbstractClass;

begin
  AbstractErrorProc := MyHndlr;

  O := TAbstractClass.Create();
  O.AbstractMethod;

  WriteLn('We''ve got here! Hooray!');
  ReadLn;
end.
</pre>
<p>This method will plug in our own <em>AbstractErrorProc</em> handler which will &#8220;remove&#8221; the return address from the stack (in our case the address back to _<em>AbstractError</em>) and then simply returns to the code that originated the call to the abstract method.</p>
<p><strong>I know it&#8217;s not very useful &#8230; but it&#8217;s fun <img src="https://s.w.org/images/core/emoji/12.0.0-1/72x72/1f642.png" alt="🙂" class="wp-smiley" style="height: 1em; max-height: 1em;" /></strong></p>
]]></content:encoded>
							<wfw:commentRss>https://alex.ciobanu.org/?feed=rss2&#038;p=38</wfw:commentRss>
		<slash:comments>0</slash:comments>
							</item>
	</channel>
</rss>

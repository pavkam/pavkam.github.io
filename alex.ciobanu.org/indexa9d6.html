<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>
	Comments on: TDelegatedEqualityComparer	</title>
	<atom:link href="https://alex.ciobanu.org/?feed=rss2&#038;p=65" rel="self" type="application/rss+xml" />
	<link>https://alex.ciobanu.org/?p=65</link>
	<description>Yet Another Programming Blog</description>
	<lastBuildDate>Fri, 06 Feb 2009 21:01:41 +0000</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.2.2</generator>
			<item>
				<title>
				By: alex				</title>
				<link>https://alex.ciobanu.org/?p=65&#038;cpage=1#comment-112</link>
		<dc:creator><![CDATA[alex]]></dc:creator>
		<pubDate>Fri, 06 Feb 2009 21:01:41 +0000</pubDate>
		<guid isPermaLink="false">http://alex.ciobanu.org/?p=65#comment-112</guid>
					<description><![CDATA[Indeed it makes sense in .NET. In native world apps with less flexibility these things are not that important.]]></description>
		<content:encoded><![CDATA[<p>Indeed it makes sense in .NET. In native world apps with less flexibility these things are not that important.</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Sergey Antonov aka oxffff				</title>
				<link>https://alex.ciobanu.org/?p=65&#038;cpage=1#comment-111</link>
		<dc:creator><![CDATA[Sergey Antonov aka oxffff]]></dc:creator>
		<pubDate>Thu, 05 Feb 2009 14:22:08 +0000</pubDate>
		<guid isPermaLink="false">http://alex.ciobanu.org/?p=65#comment-111</guid>
					<description><![CDATA[&#062;&#062;These aren’t really required in the real world. Because those are not objects &#062;&#062;thus cannot have inheritance. If you need a generic class that only accepts &#062;&#062;pointer types - do not make it generic in the first place.

And what about Value type constraint in .NET. No  inheritance. 
But it is.  It makes sence for some guys.]]></description>
		<content:encoded><![CDATA[<p>&gt;&gt;These aren’t really required in the real world. Because those are not objects &gt;&gt;thus cannot have inheritance. If you need a generic class that only accepts &gt;&gt;pointer types &#8211; do not make it generic in the first place.</p>
<p>And what about Value type constraint in .NET. No  inheritance.<br />
But it is.  It makes sence for some guys.</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: alex				</title>
				<link>https://alex.ciobanu.org/?p=65&#038;cpage=1#comment-110</link>
		<dc:creator><![CDATA[alex]]></dc:creator>
		<pubDate>Thu, 05 Feb 2009 14:07:56 +0000</pubDate>
		<guid isPermaLink="false">http://alex.ciobanu.org/?p=65#comment-110</guid>
					<description><![CDATA[&gt;&gt;Comparer via delegated operation is very time consuming operation for big collections(arrays).

True, that&#039;s why a descendant of TCustomComparer is preferred. But for small operations it&#039;s quite handy.

&gt;&gt; Arrray, String, Pointer constraints

These aren&#039;t really required in the real world. Because those are not objects thus cannot have inheritance. If you need a generic class that only accepts pointer types - do not make it generic in the first place.

As for generics for native Delphi - it&#039;s step forward for a lot of people that still prefer Object Pascal over C++.

I, for instance prefer Delphi generics over C++ templates. (matter of taste).]]></description>
		<content:encoded><![CDATA[<p>>>Comparer via delegated operation is very time consuming operation for big collections(arrays).</p>
<p>True, that&#8217;s why a descendant of TCustomComparer is preferred. But for small operations it&#8217;s quite handy.</p>
<p>>> Arrray, String, Pointer constraints</p>
<p>These aren&#8217;t really required in the real world. Because those are not objects thus cannot have inheritance. If you need a generic class that only accepts pointer types &#8211; do not make it generic in the first place.</p>
<p>As for generics for native Delphi &#8211; it&#8217;s step forward for a lot of people that still prefer Object Pascal over C++.</p>
<p>I, for instance prefer Delphi generics over C++ templates. (matter of taste).</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Sergey Antonov aka oxffff				</title>
				<link>https://alex.ciobanu.org/?p=65&#038;cpage=1#comment-109</link>
		<dc:creator><![CDATA[Sergey Antonov aka oxffff]]></dc:creator>
		<pubDate>Thu, 05 Feb 2009 13:00:59 +0000</pubDate>
		<guid isPermaLink="false">http://alex.ciobanu.org/?p=65#comment-109</guid>
					<description><![CDATA[The best way for native Delphi is to resign generics.
And to use the C++ templates with constraints. IMHO.

1. Comparer via delegated operation is very time consuming operation for big collections(arrays).
2. NET constraints have to be escalated for native delphi generics since native delphi heap objects not single rooted.

That is

Where Arrray, String, Pointer constraints Are?]]></description>
		<content:encoded><![CDATA[<p>The best way for native Delphi is to resign generics.<br />
And to use the C++ templates with constraints. IMHO.</p>
<p>1. Comparer via delegated operation is very time consuming operation for big collections(arrays).<br />
2. NET constraints have to be escalated for native delphi generics since native delphi heap objects not single rooted.</p>
<p>That is</p>
<p>Where Arrray, String, Pointer constraints Are?</p>
]]></content:encoded>
						</item>
			</channel>
</rss>

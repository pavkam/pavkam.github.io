<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>wow &#8211; YAPB</title>
	<atom:link href="https://alex.ciobanu.org/?feed=rss2&#038;tag=wow" rel="self" type="application/rss+xml" />
	<link>https://alex.ciobanu.org</link>
	<description>Yet Another Programming Blog</description>
	<lastBuildDate>Thu, 30 Oct 2008 14:48:28 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.2.2</generator>

<image>
	<url>https://alex.ciobanu.org/files/uploads/2018/05/7327309-150x150.jpg</url>
	<title>wow &#8211; YAPB</title>
	<link>https://alex.ciobanu.org</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Fond Memories: WoW</title>
		<link>https://alex.ciobanu.org/?p=17</link>
				<comments>https://alex.ciobanu.org/?p=17#comments</comments>
				<pubDate>Sun, 14 Sep 2008 10:16:15 +0000</pubDate>
		<dc:creator><![CDATA[Alexandru Ciobanu]]></dc:creator>
				<category><![CDATA[Software Development]]></category>
		<category><![CDATA[delphi]]></category>
		<category><![CDATA[LinkedIn]]></category>
		<category><![CDATA[wow]]></category>

		<guid isPermaLink="false">http://alex.ciobanu.org/?p=17</guid>
				<description><![CDATA[Came across a blog post a few weeks ago where someone was describing the methods he used to sniff WoW&#8217;s (World Of Warcraft) packets. That led me to think that I should write down about the time I... ]]></description>
								<content:encoded><![CDATA[<p>Came across a blog post a few weeks ago where someone was describing the methods he used to sniff WoW&#8217;s <em>(World Of Warcraft)</em> packets. That led me to think that I should write down about the time I have been developing the &#8220;<strong>WoW Reverse Engineering Tool</strong>&#8220;. It&#8217;s been nearly 3 years since then but hey &#8211; I did not know or care about blogging then.</p>
<p>Before I start &#8211; I am not really that passionate about WoW anyway. What attracted me was the challenge in writing such a tool.</p>
<h1>The beginning</h1>
<p>I have started participating in &#8220;underground&#8221; WoW community about 4 years ago when me and my friend (later a whole team) started gathering a database of quests for the game from all the possible sources we could get our hands on. We then developed a &#8220;compiler&#8221; that would transform that DB in the format needed by (long time defunct) WoWEmu. The first version (the IRPG QDB) would compile TCL scripts required by that particular server. Later on I realized we could bypass the whole TCL scripting by &#8220;injecting&#8221; our own DLL into the executable and simulate running of scripts. In reality all the calls to those TCL scripts would be handled directly in our DLL so the speed would be much much greater. That also gave us a big leap forward regarding the quality of the quests &#8211; we had the possibility to store much more information in memory which would not be disposed after the TCL script would end it&#8217;s execution.</p>
<p>In all this time (about 4 months) I learned a lot about WoW protocol in general so teh obvious way was to start working on a new server software. Here came along Ludmilla. It was a C++ project derivative from another GPL&#8217;ed sources we had laying around. My task was to write a good quest engine for the server while others would work on their tasks too. I will not detail too much about what happened except that the Ludmilla developers did not want to release the source back which was a breach in the GPL. This, and a talk to a member of WoW community paved the way for the <a href="http://www.mangosproject.org/forum/">MaNGOS</a> project. A lot of things happend in the mean time so we have decided to start a new WoW server written entirely in Delphi &#8211; <a href="http://code.google.com/p/yawe-mmorpg">YAWE</a>.</p>
<h1>The need for data</h1>
<p>Yes, right about the same time I was working on Ludmilla the need for a good packet sniffer became even more visible. In those days there were quite a few teams working on their WoW servers and only one IIRC had a semi-working packet sniffer. All that determined me to start working on WoWRE Tool.</p>
<p>It is important to understand that I already had good knowledge of the underlying protocol and I had access to WoW server implementations &#8211; this made my life much easier. It would have been a much bigger pain If we would have started on absolutely zero knowledge.</p>
<p>What would the new sniffer provide? Well, a good logging for all the traffic going on between server and client and a way for us to grab WoW world content and store it in a database. You see, while you would walk around in the game, the server would send you mostly 100% complete information about all objects that come into your range. We would then take that information and pack it in the required format.</p>
<p>Another problem was WoW&#8217;s &#8220;warden&#8221; software. It was a process that would monitor all other system processes and see which one is interferring with the WoW executable. This way they ensured you wouldn&#8217;t cheat. This made us realize that we needed a real TCP based &#8220;<span style="text-decoration: underline;">Man-In-The-Middle</span>&#8221; approach so that we don&#8217;t get detected!</p>
<h1>The realm server</h1>
<p>Before your WoW could connect to the actual world it would connect to a general <em>realm server</em>. Here the user would authenticate and select the actual world server he wants to connect to. Once selected WoW will receive the IP:Port of the world he wants to connect to. One very important aspect is that while communicating with the <em>realm server</em>, both parties generate a 40 bytes hash key by using the SRP6 algorithm. I will not dig too deep into this but know that it&#8217;s a very messy stuff and it takes a lot of tries to get this part right (if you&#8217;re doing a WoW server).</p>
<p>The protocol of the realm server is not yet encrypted so nothing too fancy here. I came up with a working version on this part in a few days. The only problem I had was the realm selection &#8211; there are many world servers (I mean many!) and the client can connect to all of them if it desires so. But I need to intercept that traffic too (actually that was the whole point). The decision was to buffer all that info on the sniffer (it took quite a few packets to gather all the list) and change all the IP:Port fields to point to the sniffer. The client can select any realm and try to connect but still be redirected to my software. This lead to another problem &#8211; the client may want to connect to any world he wants but still, the actual world selection must be made on the sniffer itself. But it wasn&#8217;t a big deal because people actually play on the same world most of the time so the sniffer would auto-select it.</p>
<p>After all this intermediary work, came the complicated part &#8211; communication with the world!</p>
<h1>The world server</h1>
<p>The protocols used by the realm and world servers was completely different. My opinion is that the realm server used a very old protocol (probably something from Diablo days).</p>
<p>OK, so now we&#8217;re talking with the world! But there is just garbage on the line. Nothing recognizable! The problem was that nasty SRP6 stuff. After a few tries I realized it is going to take too long to actually negotiate all this key stuff, so here came the best idea ever &#8211; I don&#8217;t even have to simulate the SRP6 negotiations. Let the real server do it. But how would I then get that 40 bytes key? SRP6 ensures that both client and server would generate it on their own so the sniffer has not way of knowing it. And we really need that key for the world server &#8211; it&#8217;s used to encrypt all the data.</p>
<p>The answer came from the knowledge of the protocol of course:</p>
<p>Client side request looks like:<em> Packet Length:</em> <strong>2 Bytes</strong>, <em>Packet ID:</em> <strong>4 Bytes</strong>, &#8230; <em>Packet data</em></p>
<p>The ecryption is a XOR-like method where the next XOR operation is dependent on the previous non-XOR&#8217;ed data. Also, only the size and the packet ID are encrypted.</p>
<p>The method I used is based on the fact that initial client-server dialog looks more like question-answer, where teh client is initiating the dialog every time. This ensures that each separate packet is flushed individually resulting in a predictable pattern. The net-result is this:</p>
<ol>
<li>Catch the client-side packet. It&#8217;s real length is most probably equal to the TCP packet length.</li>
<li>Subtract 2 from that TCP length and change the byte order.</li>
<li>Read the first 2 bytes from the packet and apply the XOR-like algorithm on them until they match the length we expect.</li>
<li>This way we have 2 bytes out of 40 of the key! Put them into an array at the required position and add another 4 to that index so the next 2 pieces are properly identified (do not forget that the packet ID is also encrypted which results in 4 key pieces being used also &#8211; but we don&#8217;t have those yet).</li>
<li>Repeat this process until all key pieces are in place!</li>
<li>When the key is ready take all the packets (that were previously buffered somewhere) and actually decrypt them properly.</li>
</ol>
<p>Note that the predictability of the packet sizes works only on client-side packets, because the server could send more game packets in one TCP chunk. This method works in 60% of the cases. Why so low? Because the client sometimes issued a very large packet that was split in 2 TCP chunks &#8211; this of course resulted in corrupted key.</p>
<p>So why stop here I said? Maybe we could get rid of that 60% problem and even speed-up things! I came up with a predictability pattern that would involve the packet ID&#8217;s. I knew which packets the client were sending so I could predict them in the initial client-server dialog. Well &#8230; that turned out to be quite a challenge:</p>
<ol>
<li>Even if I knew which packets are going to appear in the dialog, they did not come in the same order.</li>
<li>Sometimes if you wait too much time in the character selection dialog, too many PING packets would be sent so that also poses a challenge.</li>
<li>That 60% problem &#8211; well the packet that is split was actually easy to detect even without the encryption: It was a zip-packed data chunk. So I could try to unzip it and see if the result looks like what I expect it to look.</li>
</ol>
<p>The fast-key method was born! This method will detect 6 pieces of the key in one packet so that means we can collect the whole key just in 7 packets! The only down-side of this method is that I needed to update the tool for each release of WoW, because most of the time new packets were introduced.</p>
<h1>Other challenges</h1>
<p>While the actual sniffing was a big challenge, we (at YAWE) needed much more gathered information, so I decided to extend the tool into much more that just a sniffer:</p>
<p><strong>Packet helper mode:</strong> This mode looks like a calculator actually. You can enter a string for example in a edit box and it would automatically be translated into all kinds of data types &#8211; hex string, bytes, almost all data types that could have been found in WoW packets. It actually helped us a lot to identify things in newly introduced packets.</p>
<p><strong>Update Field Extractor:</strong> These fields are important in the whole protocol because they represent particual attributes of objects (e.g. Health of a player). I&#8217;d actually say that most of the traffic results in packets that depend on those fields. There are <strong>a lot</strong> of them out there and even more are being introduced with each new update. It&#8217;s imperative that the server developers know about them and what they represent. I knew there was a possibility to extract them form the WoW.exe executable but noone seemed to share that info! Well, suffice to say that it&#8217;s pretty easy actually: There is a table in the exe file that contains the names of all those fields and another one that contains their interger IDs and their types. A day of hacking and we&#8217;ve got ourselves an extractor that can generate C++, Delphi and some other formats of constants. Not sure why Blizzard would keep that info in the executable but there have been even times when debug build were released with all the packet names in the executable.</p>
<p><strong>Data file reader:</strong> A simple explorer for the data files that come bundled with the WoW. You can extract file if you want and even read DBC files which contain very important information for the server developers.</p>
<p><strong>3D terrain converter:</strong> It&#8217;s a tool that reads WoW&#8217;s map files and generates a new format suitable to be used in the server. Those files provide a mapping function <strong>Z = function(X, Y)</strong> that can be used to calculate positions and other important 3D things.</p>
<h1>Conclusion</h1>
<p>If you&#8217;re passionate about reverse engineering and like to play with other programs&#8217; brains &#8211; <strong>DO IT</strong>. Nothing can replace the old-school &#8220;<em>getting your hands dirty</em>&#8220;.</p>
<p>Anyway, the if you like to take a look at the sources of RE Tool you can find it below:</p>
<p><code>[download#3]</code></p>
]]></content:encoded>
							<wfw:commentRss>https://alex.ciobanu.org/?feed=rss2&#038;p=17</wfw:commentRss>
		<slash:comments>5</slash:comments>
							</item>
	</channel>
</rss>

<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>
	Comments on: I hate integers!	</title>
	<atom:link href="https://alex.ciobanu.org/?feed=rss2&#038;p=175" rel="self" type="application/rss+xml" />
	<link>https://alex.ciobanu.org/?p=175</link>
	<description>Yet Another Programming Blog</description>
	<lastBuildDate>Sun, 13 Sep 2009 10:47:30 +0000</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.2.2</generator>
			<item>
				<title>
				By: alex				</title>
				<link>https://alex.ciobanu.org/?p=175&#038;cpage=1#comment-481</link>
		<dc:creator><![CDATA[alex]]></dc:creator>
		<pubDate>Sun, 13 Sep 2009 10:47:30 +0000</pubDate>
		<guid isPermaLink="false">http://alex.ciobanu.org/?p=175#comment-481</guid>
					<description><![CDATA[Yes, you are right. In some cases integers are a better choice, though if the whole class structure is designed properly there are not many IFs anyway.]]></description>
		<content:encoded><![CDATA[<p>Yes, you are right. In some cases integers are a better choice, though if the whole class structure is designed properly there are not many IFs anyway.</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Aleksandr Sharahov				</title>
				<link>https://alex.ciobanu.org/?p=175&#038;cpage=1#comment-474</link>
		<dc:creator><![CDATA[Aleksandr Sharahov]]></dc:creator>
		<pubDate>Thu, 27 Aug 2009 10:20:46 +0000</pubDate>
		<guid isPermaLink="false">http://alex.ciobanu.org/?p=175#comment-474</guid>
					<description><![CDATA[I think using exclusively signed integers makes program shorter and faster. Because it does not need some ifs and mixing signed and unsigned types when comparing and calculating.]]></description>
		<content:encoded><![CDATA[<p>I think using exclusively signed integers makes program shorter and faster. Because it does not need some ifs and mixing signed and unsigned types when comparing and calculating.</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Jan Doggen				</title>
				<link>https://alex.ciobanu.org/?p=175&#038;cpage=1#comment-256</link>
		<dc:creator><![CDATA[Jan Doggen]]></dc:creator>
		<pubDate>Wed, 08 Apr 2009 06:57:56 +0000</pubDate>
		<guid isPermaLink="false">http://alex.ciobanu.org/?p=175#comment-256</guid>
					<description><![CDATA[My €0.02:

In the age of powerful computers and powerful compilers, I use it all: warnings on, range and overflow checks on, and using variable types that match their intended use:
If I know a number is positive, it will be declared as a word; if I know it will only count to e.g. 100, it will be declared as a byte. 
That way, if I make a mistake, I have the compiler alert me to it.

The only concession here, which bites (bytes?) me occasionally is the empty for loop. But these usually are local and short-lived variables, so declaring these as int is no big deal.

Jan]]></description>
		<content:encoded><![CDATA[<p>My €0.02:</p>
<p>In the age of powerful computers and powerful compilers, I use it all: warnings on, range and overflow checks on, and using variable types that match their intended use:<br />
If I know a number is positive, it will be declared as a word; if I know it will only count to e.g. 100, it will be declared as a byte.<br />
That way, if I make a mistake, I have the compiler alert me to it.</p>
<p>The only concession here, which bites (bytes?) me occasionally is the empty for loop. But these usually are local and short-lived variables, so declaring these as int is no big deal.</p>
<p>Jan</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: alex				</title>
				<link>https://alex.ciobanu.org/?p=175&#038;cpage=1#comment-252</link>
		<dc:creator><![CDATA[alex]]></dc:creator>
		<pubDate>Mon, 06 Apr 2009 07:41:36 +0000</pubDate>
		<guid isPermaLink="false">http://alex.ciobanu.org/?p=175#comment-252</guid>
					<description><![CDATA[For me, unsigned integers &quot;simply make sense&quot; (tm). Of course you must take care if you want to use them in any algorithm. I had problems starting with quick sort, binary search to any loop.

And yes, turning on the range checking would help a lot ... but who does that?]]></description>
		<content:encoded><![CDATA[<p>For me, unsigned integers &#8220;simply make sense&#8221; &#8482;. Of course you must take care if you want to use them in any algorithm. I had problems starting with quick sort, binary search to any loop.</p>
<p>And yes, turning on the range checking would help a lot &#8230; but who does that?</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Keld R. Hansen				</title>
				<link>https://alex.ciobanu.org/?p=175&#038;cpage=1#comment-251</link>
		<dc:creator><![CDATA[Keld R. Hansen]]></dc:creator>
		<pubDate>Mon, 06 Apr 2009 06:18:30 +0000</pubDate>
		<guid isPermaLink="false">http://alex.ciobanu.org/?p=175#comment-251</guid>
					<description><![CDATA[@Eric:

&#062; You’re looking at it from the wrong side, the result of a function is not (and
&#062; never was) intended to be limited to the possible ranges of a result value, it’s
&#062; always a greater container

You are trying to impose the underlying limitations of the compiler/CPU upon the programmer&#039;s logical thinking, which is not the way to do things. The compiler should be at the service of the programmer, not the other way around.

If there&#039;s no possibility for a function to ever return negative values, then it simply makes no logical sense for a function to limit its return value options just because the underlying compiler/CPU makes it &quot;more efficient&quot;. A good programming language is as far removed from the underlying CPU as possible, so that the programmer doesn&#039;t have to think in those terms or operate within those restrictions...

There has been numerous occasions in the past where a simple word - &quot;unsigned&quot; - would had meant that that problem had been non-existing.

&#062; If he had used “unsigned int” you could have screamed “YOU HAD TO USE A
&#062; FILE of 4 GB IN SIZE [...] BECAUSE A PROGRAMMER WAS LAZY AND USED
&#062; 32bit INTEGERS INSTEAD OF 64 bit ONES”

Yes - the problem returned again at a later date, but my point is that - at the time - there was no compiler (for the PC) who HAD a 64bit integer (signed OR unsigned), so that issue could only have been solved at that time by using the COMP type (80-bit &quot;floating point integer&quot; of the FPU, which didn&#039;t necessarily exist in the CPUs at the time), whereas a simple &quot;unsigned&quot; already WAS available in the compilers at the time, and so there was no excuse for the laziness of the programmer to use signed integers as the return types for such functions.

Restricting the possible return values of a function to allow values that can NEVER be returned is ILLOGICAL - plain and simple. And it turns the problems upside down with respect to the human/computer interface. The programmer should not be thinking about issues like these - that&#039;s the compiler&#039;s job.

&#062; I don’t understand. You don’t have to cater for empty lists using the more
&#062; efficient, and more normal, approach either:
&#062;
&#062; for i := 0 to Pred(sl.Count) do if sl[i] = ” then …
&#062;
&#062; This works exactly the same way for sl.Count = 0 as your approach, 

Nope. Because since I KNOW that there&#039;s never a negative index needed, I then - of course - declare my variable to be an UNSIGNED integer, and then the compiler makes a fatal mistake and calculates that PRED(0) = 4Gb-1 (as described in the original post), which leads to a &quot;String index out of range&quot; exception in your IF statement...

If the compiler was smart enough to recognize this flaw, then the problem would be smaller, but it isn&#039;t, and this is a good example of the compiler/CPU enforcing its view on the world on the programmer, which it never should (in an ideal world), or at least should stay away from as much as possible.

&#062; It makes all the sense in the world because that number is one number
&#062; you’re bound to use in arithmetics (subtract to or from it, compare, etc.), and
&#062; it makes no sense to do arithmetic on unsigned numbers (unless you enjoy
&#062; aiming loaded guns at feet).

It makes perfect sence. How about this:

FUNCTION DiskSpaceUsed(Drive : CHAR) : Cardinal;
  BEGIN
    Result:=DiskSize(Drive)-DiskFree(Drive)
  END;

This is a perfect example of a (simplistic) function where negative values should never come into play, since there&#039;s NEVER a possibility of ANY of the values to become negative, and NEVER a possibility of DiskFree being bigger than DiskSize.

Or what about this:

GetMem(Buffer,LENGTH(S)+SizeOf(Structure))

Once again, negative values has nothing whatsoever to do here, as they can never come into play.

So plain unsigned arithmetic makes perfect sense in many cases...]]></description>
		<content:encoded><![CDATA[<p>@Eric:</p>
<p>&gt; You’re looking at it from the wrong side, the result of a function is not (and<br />
&gt; never was) intended to be limited to the possible ranges of a result value, it’s<br />
&gt; always a greater container</p>
<p>You are trying to impose the underlying limitations of the compiler/CPU upon the programmer&#8217;s logical thinking, which is not the way to do things. The compiler should be at the service of the programmer, not the other way around.</p>
<p>If there&#8217;s no possibility for a function to ever return negative values, then it simply makes no logical sense for a function to limit its return value options just because the underlying compiler/CPU makes it &#8220;more efficient&#8221;. A good programming language is as far removed from the underlying CPU as possible, so that the programmer doesn&#8217;t have to think in those terms or operate within those restrictions&#8230;</p>
<p>There has been numerous occasions in the past where a simple word &#8211; &#8220;unsigned&#8221; &#8211; would had meant that that problem had been non-existing.</p>
<p>&gt; If he had used “unsigned int” you could have screamed “YOU HAD TO USE A<br />
&gt; FILE of 4 GB IN SIZE [&#8230;] BECAUSE A PROGRAMMER WAS LAZY AND USED<br />
&gt; 32bit INTEGERS INSTEAD OF 64 bit ONES”</p>
<p>Yes &#8211; the problem returned again at a later date, but my point is that &#8211; at the time &#8211; there was no compiler (for the PC) who HAD a 64bit integer (signed OR unsigned), so that issue could only have been solved at that time by using the COMP type (80-bit &#8220;floating point integer&#8221; of the FPU, which didn&#8217;t necessarily exist in the CPUs at the time), whereas a simple &#8220;unsigned&#8221; already WAS available in the compilers at the time, and so there was no excuse for the laziness of the programmer to use signed integers as the return types for such functions.</p>
<p>Restricting the possible return values of a function to allow values that can NEVER be returned is ILLOGICAL &#8211; plain and simple. And it turns the problems upside down with respect to the human/computer interface. The programmer should not be thinking about issues like these &#8211; that&#8217;s the compiler&#8217;s job.</p>
<p>&gt; I don’t understand. You don’t have to cater for empty lists using the more<br />
&gt; efficient, and more normal, approach either:<br />
&gt;<br />
&gt; for i := 0 to Pred(sl.Count) do if sl[i] = ” then …<br />
&gt;<br />
&gt; This works exactly the same way for sl.Count = 0 as your approach, </p>
<p>Nope. Because since I KNOW that there&#8217;s never a negative index needed, I then &#8211; of course &#8211; declare my variable to be an UNSIGNED integer, and then the compiler makes a fatal mistake and calculates that PRED(0) = 4Gb-1 (as described in the original post), which leads to a &#8220;String index out of range&#8221; exception in your IF statement&#8230;</p>
<p>If the compiler was smart enough to recognize this flaw, then the problem would be smaller, but it isn&#8217;t, and this is a good example of the compiler/CPU enforcing its view on the world on the programmer, which it never should (in an ideal world), or at least should stay away from as much as possible.</p>
<p>&gt; It makes all the sense in the world because that number is one number<br />
&gt; you’re bound to use in arithmetics (subtract to or from it, compare, etc.), and<br />
&gt; it makes no sense to do arithmetic on unsigned numbers (unless you enjoy<br />
&gt; aiming loaded guns at feet).</p>
<p>It makes perfect sence. How about this:</p>
<p>FUNCTION DiskSpaceUsed(Drive : CHAR) : Cardinal;<br />
  BEGIN<br />
    Result:=DiskSize(Drive)-DiskFree(Drive)<br />
  END;</p>
<p>This is a perfect example of a (simplistic) function where negative values should never come into play, since there&#8217;s NEVER a possibility of ANY of the values to become negative, and NEVER a possibility of DiskFree being bigger than DiskSize.</p>
<p>Or what about this:</p>
<p>GetMem(Buffer,LENGTH(S)+SizeOf(Structure))</p>
<p>Once again, negative values has nothing whatsoever to do here, as they can never come into play.</p>
<p>So plain unsigned arithmetic makes perfect sense in many cases&#8230;</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Eric				</title>
				<link>https://alex.ciobanu.org/?p=175&#038;cpage=1#comment-250</link>
		<dc:creator><![CDATA[Eric]]></dc:creator>
		<pubDate>Mon, 06 Apr 2009 05:41:28 +0000</pubDate>
		<guid isPermaLink="false">http://alex.ciobanu.org/?p=175#comment-250</guid>
					<description><![CDATA[There was a time when the concept of &quot;zero&quot; didn&#039;t exist, I guess there were long philosophical discussions back then, that it didn&#039;t make sense to care about what didn&#039;t exist ^_^

&#062;Unsigned integers makes sense EVERYWHERE where a negative value is simply 
&#062;impossible. F.ex. in LENGTH, SizeOf, FileSize, DiskFree, DiskSize

You&#039;re looking at it from the wrong side, the result of a function is not (and never was) intended to be limited to the possible ranges of a result value, it&#039;s always a greater container (and thankfully so, I can&#039;t even begin to think of mess we would be in if result values of all functions were constrained to the strictest datatype that could hold its result).

No, the result of a function is intended to be... *used*. gulp.

And it&#039;s a bit like in the non programming world out there: negative values were invented for a good mathematical reason, and they make sense even when the real-world possible &quot;results&quot; are only strictly positive.

&#062;YOU HAD TO CREATE A FILE OF 2 GB IN SIZE TO GET THE AVAILABLE DISK
&#062;SPACE DOWN BELOW 2 GB JUST BECAUSE A PROGRAMMER WAS LAZY AND
&#062;USED “int” INSTEAD OF “unsiged int”.

If he had used &quot;unsigned int&quot; you could have screamed &quot;YOU HAD TO USE A FILE of 4 GB IN SIZE  [...] BECAUSE A PROGRAMMER WAS LAZY AND USED 32bit INTEGERS INSTEAD OF 64 bit ONES&quot;

&#062;Since a disk NEVER can have a negative amount of available space, it makes
&#062; no sense to have a DiskFree function return a SIGNED integer. NONE AT ALL…

It makes all the sense in the world because that number is one number you&#039;re bound to use in arithmetics (subtract to or from it, compare, etc.), and it makes no sense to do arithmetic on unsigned numbers (unless you enjoy aiming loaded guns at feet).
So better be clean and pass an integer value you can do arithmetic on, than one involving an unsafe conversion or an optional step to a higher precision representation (which if not done, would result in a gun at foot).

Unsigned numbers are for binary masking, shifting and other special case situations. Heck, it would probably be safer if you could only access them in ASM ;)]]></description>
		<content:encoded><![CDATA[<p>There was a time when the concept of &#8220;zero&#8221; didn&#8217;t exist, I guess there were long philosophical discussions back then, that it didn&#8217;t make sense to care about what didn&#8217;t exist ^_^</p>
<p>&gt;Unsigned integers makes sense EVERYWHERE where a negative value is simply<br />
&gt;impossible. F.ex. in LENGTH, SizeOf, FileSize, DiskFree, DiskSize</p>
<p>You&#8217;re looking at it from the wrong side, the result of a function is not (and never was) intended to be limited to the possible ranges of a result value, it&#8217;s always a greater container (and thankfully so, I can&#8217;t even begin to think of mess we would be in if result values of all functions were constrained to the strictest datatype that could hold its result).</p>
<p>No, the result of a function is intended to be&#8230; *used*. gulp.</p>
<p>And it&#8217;s a bit like in the non programming world out there: negative values were invented for a good mathematical reason, and they make sense even when the real-world possible &#8220;results&#8221; are only strictly positive.</p>
<p>&gt;YOU HAD TO CREATE A FILE OF 2 GB IN SIZE TO GET THE AVAILABLE DISK<br />
&gt;SPACE DOWN BELOW 2 GB JUST BECAUSE A PROGRAMMER WAS LAZY AND<br />
&gt;USED “int” INSTEAD OF “unsiged int”.</p>
<p>If he had used &#8220;unsigned int&#8221; you could have screamed &#8220;YOU HAD TO USE A FILE of 4 GB IN SIZE  [&#8230;] BECAUSE A PROGRAMMER WAS LAZY AND USED 32bit INTEGERS INSTEAD OF 64 bit ONES&#8221;</p>
<p>&gt;Since a disk NEVER can have a negative amount of available space, it makes<br />
&gt; no sense to have a DiskFree function return a SIGNED integer. NONE AT ALL…</p>
<p>It makes all the sense in the world because that number is one number you&#8217;re bound to use in arithmetics (subtract to or from it, compare, etc.), and it makes no sense to do arithmetic on unsigned numbers (unless you enjoy aiming loaded guns at feet).<br />
So better be clean and pass an integer value you can do arithmetic on, than one involving an unsafe conversion or an optional step to a higher precision representation (which if not done, would result in a gun at foot).</p>
<p>Unsigned numbers are for binary masking, shifting and other special case situations. Heck, it would probably be safer if you could only access them in ASM 😉</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Jolyon Smith				</title>
				<link>https://alex.ciobanu.org/?p=175&#038;cpage=1#comment-249</link>
		<dc:creator><![CDATA[Jolyon Smith]]></dc:creator>
		<pubDate>Sun, 05 Apr 2009 22:04:20 +0000</pubDate>
		<guid isPermaLink="false">http://alex.ciobanu.org/?p=175#comment-249</guid>
					<description><![CDATA[@Keld:

    FOR I:=1 TO SL.Count DO IF SL[PRED(I)]=” THEN …

    This way I don’t have to cater specifically for the case 
      where there’s no items in the String List…


I don&#039;t understand.  You don&#039;t have to cater for empty lists using the more efficient, and more normal, approach either:

    for i := 0 to Pred(sl.Count) do
      if sl[i] = ” then …

This works exactly the same way for sl.Count = 0 as your approach, but has the added benefit of restricting the need to Pred() to the upper limit of the loop.  Otherwise you have to remember to Pred() every reference to the loop counter variable, which is less efficient and just additional opportunities to forget.]]></description>
		<content:encoded><![CDATA[<p>@Keld:</p>
<p>    FOR I:=1 TO SL.Count DO IF SL[PRED(I)]=” THEN …</p>
<p>    This way I don’t have to cater specifically for the case<br />
      where there’s no items in the String List…</p>
<p>I don&#8217;t understand.  You don&#8217;t have to cater for empty lists using the more efficient, and more normal, approach either:</p>
<p>    for i := 0 to Pred(sl.Count) do<br />
      if sl[i] = ” then …</p>
<p>This works exactly the same way for sl.Count = 0 as your approach, but has the added benefit of restricting the need to Pred() to the upper limit of the loop.  Otherwise you have to remember to Pred() every reference to the loop counter variable, which is less efficient and just additional opportunities to forget.</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Keld R. Hansen				</title>
				<link>https://alex.ciobanu.org/?p=175&#038;cpage=1#comment-248</link>
		<dc:creator><![CDATA[Keld R. Hansen]]></dc:creator>
		<pubDate>Sun, 05 Apr 2009 21:36:31 +0000</pubDate>
		<guid isPermaLink="false">http://alex.ciobanu.org/?p=175#comment-248</guid>
					<description><![CDATA[@Eric:

Unsigned integers makes sense EVERYWHERE where a negative value is simply impossible. F.ex. in LENGTH, SizeOf, FileSize, DiskFree, DiskSize

Just think back to a time where 2Gb was a HUGE file. Think of how many lazy programmers were caught off guard when HDD sizes crossed that magic boundary and you were told that there wasn&#039;t enough space available on your drive when you had 3.5 Gb free space.

YOU HAD TO CREATE A FILE OF 2 GB IN SIZE TO GET THE AVAILABLE DISK SPACE DOWN BELOW 2 GB JUST BECAUSE A PROGRAMMER WAS LAZY AND USED &quot;int&quot; INSTEAD OF &quot;unsiged int&quot;.

Since a disk NEVER can have a negative amount of available space, it makes no sense to have a DiskFree function return a SIGNED integer. NONE AT ALL...]]></description>
		<content:encoded><![CDATA[<p>@Eric:</p>
<p>Unsigned integers makes sense EVERYWHERE where a negative value is simply impossible. F.ex. in LENGTH, SizeOf, FileSize, DiskFree, DiskSize</p>
<p>Just think back to a time where 2Gb was a HUGE file. Think of how many lazy programmers were caught off guard when HDD sizes crossed that magic boundary and you were told that there wasn&#8217;t enough space available on your drive when you had 3.5 Gb free space.</p>
<p>YOU HAD TO CREATE A FILE OF 2 GB IN SIZE TO GET THE AVAILABLE DISK SPACE DOWN BELOW 2 GB JUST BECAUSE A PROGRAMMER WAS LAZY AND USED &#8220;int&#8221; INSTEAD OF &#8220;unsiged int&#8221;.</p>
<p>Since a disk NEVER can have a negative amount of available space, it makes no sense to have a DiskFree function return a SIGNED integer. NONE AT ALL&#8230;</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Keld R. Hansen				</title>
				<link>https://alex.ciobanu.org/?p=175&#038;cpage=1#comment-247</link>
		<dc:creator><![CDATA[Keld R. Hansen]]></dc:creator>
		<pubDate>Sun, 05 Apr 2009 21:29:17 +0000</pubDate>
		<guid isPermaLink="false">http://alex.ciobanu.org/?p=175#comment-247</guid>
					<description><![CDATA[I couldn&#039;t agree more with the original post. Another thing I dislike is that indices are counted from 0 - this leads to the exact problem described here...

Indices should be from 1..Count and not from 0..Count-1

What makes more logical sense:

FOR I:=1 TO Count

or

FOR I:=0 TO Count-1

?

I know, that in my head, if I need to iterate over 100 items, I count from 1 to 100, not from 0 to 99...

This is also why I always code my loops as:

FOR I:=1 TO SL.Count DO IF SL[PRED(I)]=&#039;&#039; THEN ...

This way I don&#039;t have to cater specifically for the case where there&#039;s no items in the String List...]]></description>
		<content:encoded><![CDATA[<p>I couldn&#8217;t agree more with the original post. Another thing I dislike is that indices are counted from 0 &#8211; this leads to the exact problem described here&#8230;</p>
<p>Indices should be from 1..Count and not from 0..Count-1</p>
<p>What makes more logical sense:</p>
<p>FOR I:=1 TO Count</p>
<p>or</p>
<p>FOR I:=0 TO Count-1</p>
<p>?</p>
<p>I know, that in my head, if I need to iterate over 100 items, I count from 1 to 100, not from 0 to 99&#8230;</p>
<p>This is also why I always code my loops as:</p>
<p>FOR I:=1 TO SL.Count DO IF SL[PRED(I)]=&#8221; THEN &#8230;</p>
<p>This way I don&#8217;t have to cater specifically for the case where there&#8217;s no items in the String List&#8230;</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: K.A.				</title>
				<link>https://alex.ciobanu.org/?p=175&#038;cpage=1#comment-246</link>
		<dc:creator><![CDATA[K.A.]]></dc:creator>
		<pubDate>Sun, 05 Apr 2009 21:23:20 +0000</pubDate>
		<guid isPermaLink="false">http://alex.ciobanu.org/?p=175#comment-246</guid>
					<description><![CDATA[And, of course, many CPUs are optimized for signed integers, and your code will run slightly faster with integers than with cardinals and words.]]></description>
		<content:encoded><![CDATA[<p>And, of course, many CPUs are optimized for signed integers, and your code will run slightly faster with integers than with cardinals and words.</p>
]]></content:encoded>
						</item>
			</channel>
</rss>

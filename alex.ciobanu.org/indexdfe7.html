<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>
	Comments on: Parameter checking	</title>
	<atom:link href="https://alex.ciobanu.org/?feed=rss2&#038;p=101" rel="self" type="application/rss+xml" />
	<link>https://alex.ciobanu.org/?p=101</link>
	<description>Yet Another Programming Blog</description>
	<lastBuildDate>Mon, 02 Mar 2009 15:37:31 +0000</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.2.2</generator>
			<item>
				<title>
				By: alex				</title>
				<link>https://alex.ciobanu.org/?p=101&#038;cpage=1#comment-145</link>
		<dc:creator><![CDATA[alex]]></dc:creator>
		<pubDate>Mon, 02 Mar 2009 15:37:31 +0000</pubDate>
		<guid isPermaLink="false">http://alex.ciobanu.org/?p=101#comment-145</guid>
					<description><![CDATA[@Thomas Mueller - Yes, I know there is an overload for copy, but thanks anyway ;)

@Xepol - Exceptions should NOT be used to control code behavior. That being said, exceptions would not be thrown if you do everything correctly from the start. If, you make a mistake and pass 0 it would notify you. I see this as the best tool to avoid more complex mistakes. Sometimes you may pass 0 even if you did not indent to which would result in a &quot;silent failure&quot;.

@Frank - We&#039;re not talking about Delphi pro&#039;s here :) Think about many new developers which come from &quot;strict&quot; environments. That can be really hard for them. Knowing each side-effect is a daunting task.

@Ralph - I did not say it&#039;s a side-effect per-se. It can lead to side-effects if you&#039;re new to Delphi and simply do not read the documentation (which happens a lot since the name of the function + parameters say a lot themselves).

I believe there are 2 schools of thought here, first - The library assumes you know what you are doing and if not, it&#039;s your fault. And the second - the library tends to always assume the worst about programmers and tends to make as many checks as possible to avoid side-effects.

While I love freedom, sometimes having something/someone watch over your back is also a good thing.]]></description>
		<content:encoded><![CDATA[<p>@Thomas Mueller &#8211; Yes, I know there is an overload for copy, but thanks anyway ðŸ˜‰</p>
<p>@Xepol &#8211; Exceptions should NOT be used to control code behavior. That being said, exceptions would not be thrown if you do everything correctly from the start. If, you make a mistake and pass 0 it would notify you. I see this as the best tool to avoid more complex mistakes. Sometimes you may pass 0 even if you did not indent to which would result in a &#8220;silent failure&#8221;.</p>
<p>@Frank &#8211; We&#8217;re not talking about Delphi pro&#8217;s here ðŸ™‚ Think about many new developers which come from &#8220;strict&#8221; environments. That can be really hard for them. Knowing each side-effect is a daunting task.</p>
<p>@Ralph &#8211; I did not say it&#8217;s a side-effect per-se. It can lead to side-effects if you&#8217;re new to Delphi and simply do not read the documentation (which happens a lot since the name of the function + parameters say a lot themselves).</p>
<p>I believe there are 2 schools of thought here, first &#8211; The library assumes you know what you are doing and if not, it&#8217;s your fault. And the second &#8211; the library tends to always assume the worst about programmers and tends to make as many checks as possible to avoid side-effects.</p>
<p>While I love freedom, sometimes having something/someone watch over your back is also a good thing.</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Ralph				</title>
				<link>https://alex.ciobanu.org/?p=101&#038;cpage=1#comment-144</link>
		<dc:creator><![CDATA[Ralph]]></dc:creator>
		<pubDate>Mon, 02 Mar 2009 02:22:49 +0000</pubDate>
		<guid isPermaLink="false">http://alex.ciobanu.org/?p=101#comment-144</guid>
					<description><![CDATA[The parameter values you describe are not &#039;invalid&#039;. The description of the Delphi procedure &#039;delete&#039; is as follows (check the documentation)
----
In Delphi code, Delete removes a substring of Count characters from string S starting with S[Index]. S is a string-type variable. Index and Count are integer-type expressions. 
If index is larger than the length of the string or less than 1, no characters are deleted.
If count specifies more characters than remain starting at the index, Delete removes the rest of the string. If count is less than or equal to 0, no characters are deleted.
----
You are not, therefore, relying on &#039;side-effects&#039; at all.]]></description>
		<content:encoded><![CDATA[<p>The parameter values you describe are not &#8216;invalid&#8217;. The description of the Delphi procedure &#8216;delete&#8217; is as follows (check the documentation)<br />
&#8212;-<br />
In Delphi code, Delete removes a substring of Count characters from string S starting with S[Index]. S is a string-type variable. Index and Count are integer-type expressions.<br />
If index is larger than the length of the string or less than 1, no characters are deleted.<br />
If count specifies more characters than remain starting at the index, Delete removes the rest of the string. If count is less than or equal to 0, no characters are deleted.<br />
&#8212;-<br />
You are not, therefore, relying on &#8216;side-effects&#8217; at all.</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Frank				</title>
				<link>https://alex.ciobanu.org/?p=101&#038;cpage=1#comment-143</link>
		<dc:creator><![CDATA[Frank]]></dc:creator>
		<pubDate>Sat, 28 Feb 2009 12:31:10 +0000</pubDate>
		<guid isPermaLink="false">http://alex.ciobanu.org/?p=101#comment-143</guid>
					<description><![CDATA[Hi Alex,

I understand your problem with the &quot;invalid&quot; parameters, and the problems they can cause. However I think that the RTL should be implemented with the minimum of checks to ensure as fast execution as possible. One of the really great things about Delphi is that the compiler produces very fast, and highly optimized code. This is essential to some of the programs I write, and there really is no need to check your parameters, if you know that they can only be valid.

If I need to write some number crunching code that must be as effective as possible, then I would like as few param-checks as possible to speed up execution. If all RTL routines checks their parameters by default, then it would slow the resulting code so much that I would have to find another language to write my number crunchers, and I would rather not :-)

If- or when - I need to check my parameters, I must do is my self.]]></description>
		<content:encoded><![CDATA[<p>Hi Alex,</p>
<p>I understand your problem with the &#8220;invalid&#8221; parameters, and the problems they can cause. However I think that the RTL should be implemented with the minimum of checks to ensure as fast execution as possible. One of the really great things about Delphi is that the compiler produces very fast, and highly optimized code. This is essential to some of the programs I write, and there really is no need to check your parameters, if you know that they can only be valid.</p>
<p>If I need to write some number crunching code that must be as effective as possible, then I would like as few param-checks as possible to speed up execution. If all RTL routines checks their parameters by default, then it would slow the resulting code so much that I would have to find another language to write my number crunchers, and I would rather not ðŸ™‚</p>
<p>If- or when &#8211; I need to check my parameters, I must do is my self.</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Xepol				</title>
				<link>https://alex.ciobanu.org/?p=101&#038;cpage=1#comment-142</link>
		<dc:creator><![CDATA[Xepol]]></dc:creator>
		<pubDate>Fri, 27 Feb 2009 20:32:46 +0000</pubDate>
		<guid isPermaLink="false">http://alex.ciobanu.org/?p=101#comment-142</guid>
					<description><![CDATA[I see this as exactly the opposite of what you describe.  The Delete routing checks the result and does nothing, so it does check.  If you ask to delete 10 characters from point Y and only 8 exist, how is that really an error?  The end result is exactly the same as if 10 characters did exist after all.

I know that dotNet will through exceptions in cases like this, but I do not see this as a saner thing to do - rather yet another way to raise very expensive exceptions (dotNet makes them VERY expensive to raise unlike the VCL)]]></description>
		<content:encoded><![CDATA[<p>I see this as exactly the opposite of what you describe.  The Delete routing checks the result and does nothing, so it does check.  If you ask to delete 10 characters from point Y and only 8 exist, how is that really an error?  The end result is exactly the same as if 10 characters did exist after all.</p>
<p>I know that dotNet will through exceptions in cases like this, but I do not see this as a saner thing to do &#8211; rather yet another way to raise very expensive exceptions (dotNet makes them VERY expensive to raise unlike the VCL)</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Thomas Mueller				</title>
				<link>https://alex.ciobanu.org/?p=101&#038;cpage=1#comment-141</link>
		<dc:creator><![CDATA[Thomas Mueller]]></dc:creator>
		<pubDate>Fri, 27 Feb 2009 19:45:48 +0000</pubDate>
		<guid isPermaLink="false">http://alex.ciobanu.org/?p=101#comment-141</guid>
					<description><![CDATA[@alex: There is an overloaded version of Copy, that only takes two parameters. I don&#039;t know about Delete.]]></description>
		<content:encoded><![CDATA[<p>@alex: There is an overloaded version of Copy, that only takes two parameters. I don&#8217;t know about Delete.</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: alex				</title>
				<link>https://alex.ciobanu.org/?p=101&#038;cpage=1#comment-140</link>
		<dc:creator><![CDATA[alex]]></dc:creator>
		<pubDate>Fri, 27 Feb 2009 18:00:06 +0000</pubDate>
		<guid isPermaLink="false">http://alex.ciobanu.org/?p=101#comment-140</guid>
					<description><![CDATA[Why not define a overloaded version of Delete and Copy then? Those would not have the last parameter (the count of elements). That would be more correct and safe IMO.

And yes, I would have passed Length(Result) there (to avoid &quot;magic&quot; numerical constants), but for the sake of correctness I had to type in the proper calculation of the length.]]></description>
		<content:encoded><![CDATA[<p>Why not define a overloaded version of Delete and Copy then? Those would not have the last parameter (the count of elements). That would be more correct and safe IMO.</p>
<p>And yes, I would have passed Length(Result) there (to avoid &#8220;magic&#8221; numerical constants), but for the sake of correctness I had to type in the proper calculation of the length.</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Keld R. Hansen				</title>
				<link>https://alex.ciobanu.org/?p=101&#038;cpage=1#comment-139</link>
		<dc:creator><![CDATA[Keld R. Hansen]]></dc:creator>
		<pubDate>Fri, 27 Feb 2009 17:52:12 +0000</pubDate>
		<guid isPermaLink="false">http://alex.ciobanu.org/?p=101#comment-139</guid>
					<description><![CDATA[I rely a lot on the &quot;safeness&quot; of passing &quot;too much&quot; information to string functions, such as COPY, DELETE etc.

For example:

P:=POS(&#039; &#039;,STR);
IF P&#062;0 THEN StrippedFirstWord:=COPY(STR,P+1,$7FFFFFFF) ELSE StrippedFirstWord:=&#039;&#039;;

I don&#039;t care how many characters are after the space - I just want them all. That&#039;s one of the things that annoys the h*ll out of me when I (at work - not at home! :-)) have to program in C#. It&#039;s a real PITA to be forced to do these kinds of checks - so much so, that I have made my own COPY functions that I use in these cases...

Likewise, your DELETE in the *first* example, I would simply code

DELETE(Result,I,$7FFFFFFF)

or

Result:=COPY(Result,I+1,$7FFFFFFF)

No need to spend code bytes and CPU cycles to calculate the number of characters to delete at EACH AND EVERY CALL, when this just as easily could be done within the routine itself.]]></description>
		<content:encoded><![CDATA[<p>I rely a lot on the &#8220;safeness&#8221; of passing &#8220;too much&#8221; information to string functions, such as COPY, DELETE etc.</p>
<p>For example:</p>
<p>P:=POS(&#8216; &#8216;,STR);<br />
IF P&gt;0 THEN StrippedFirstWord:=COPY(STR,P+1,$7FFFFFFF) ELSE StrippedFirstWord:=&#8221;;</p>
<p>I don&#8217;t care how many characters are after the space &#8211; I just want them all. That&#8217;s one of the things that annoys the h*ll out of me when I (at work &#8211; not at home! :-)) have to program in C#. It&#8217;s a real PITA to be forced to do these kinds of checks &#8211; so much so, that I have made my own COPY functions that I use in these cases&#8230;</p>
<p>Likewise, your DELETE in the *first* example, I would simply code</p>
<p>DELETE(Result,I,$7FFFFFFF)</p>
<p>or</p>
<p>Result:=COPY(Result,I+1,$7FFFFFFF)</p>
<p>No need to spend code bytes and CPU cycles to calculate the number of characters to delete at EACH AND EVERY CALL, when this just as easily could be done within the routine itself.</p>
]]></content:encoded>
						</item>
			</channel>
</rss>
